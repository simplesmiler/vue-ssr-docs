# Представляем Bundle Renderer

## Проблемы с обычным SSR

До этого момента мы предполагали, что сборку с кодом серверной части будет напрямую использоваться сервером через `require`:

``` js
const createApp = require('/path/to/built-server-bundle.js')
```

Выглядит просто, однако всякий раз, когда вы редактируете исходный код вашего приложения, вам понадобится остановить и перезапустить сервер. Это очень плохо влияет на производительность во время разработки. К тому же, Node.js не поддерживает source maps нативно.

## Добавляем BundleRenderer

`vue-server-renderer` предоставляет API, названное `createBundleRenderer` для решения этой проблемы. С помощью Webpack-плагина, серверная сборка создаётся как специальный JSON-файл, который может быть передан в рендерер. Как только рендерер создан, использование не будет отличаться от обычного рендерера, но появятся некоторые преимущества:

- Встроенная поддержка source map (с помощью `devtool: 'source-map'` в конфигурации Webpack)

- Горячая перезагрузка в процессе разработки и даже развёртывания (путём простого чтения обновлённого пакета и пересоздания экземпляра рендерера)

- Внедрение критического CSS (при использовании `*.vue` файлов): автоматически встраивает CSS, необходимый компонентам во время рендеринга. Подробнее в разделе [CSS](./css.md).

- Внедрение ресурсов с помощью [clientManifest](./api.md#clientmanifest): автоматически добавляет оптимальные директивы preload и prefetch, а также фрагменты кода, необходимые для первоначального рендеринга.

---

Мы обсудим, как настроить Webpack для генерации необходимых частей для рендерера в следующем разделе, но сейчас давайте предположим, что у нас уже есть всё необходимое, и вот как создавать рендерер:

``` js
const { createBundleRenderer } = require('vue-server-renderer')

const renderer = createBundleRenderer(serverBundle, {
  runInNewContext: false, // рекомендуется
  template, // (опционально) шаблон страницы
  clientManifest // (опционально) манифест клиентской сборки
})

// внутри обработчика сервера...
server.get('*', (req, res) => {
  const context = { url: req.url }
  // Нет необходимости передавать приложение здесь, потому что оно автоматически создаётся
  // при выполнении сборки. Теперь наш сервер отделён от нашего приложения Vue!
  renderer.renderToString(context, (err, html) => {
    // обработка ошибок...
    res.end(html)
  })
})
```

Когда `renderToString` вызывается в рендерере, он автоматически выполнит функцию, экспортируемую сборкой для создания экземпляра приложения (передавая `context` в качестве аргумента), а затем рендерит его.

---

### Опция `runInNewContext`

По умолчанию, для каждого рендера сборки будет создаваться новый контекст V8 и повторно исполняться вся сборка. Это имеет некоторые преимущества — например, нам не нужно будет беспокоиться о проблеме «синглетонов с состоянием», о которой упоминалось ранее. Однако, этот режим требует значительных затрат производительности, поскольку повторное выполнение всей сборки стоит дорого, особенно когда приложение становится большим.

В `vue-server-renderer >= 2.3.0`, эта опция по-прежнему установлена по умолчанию в `true` для обеспечения обратной совместимости, но рекомендуется использовать `runInNewContext: false` всегда, когда это возможно.

Обратите внимание, что при использовании `runInNewContext: false`, сборка всё ещё **выполняется в отдельном контексте `global`**, но только один раз. Это предотвращает случайное загрязнение объекта `global` серверного процесса. Отличие от поведения по умолчанию заключается в том, что он не создаёт **новых** контекстов для каждого вызова рендера.