# Справочник API

## `createRenderer([options])`

Создаёт экземпляр [`Renderer`](#class-renderer) с (опциональными) [настройками](#renderer-options).

``` js
const { createRenderer } = require('vue-server-renderer')
const renderer = createRenderer({ ... })
```

## `createBundleRenderer(bundle[, options])`

Создаёт экземпляр [`BundleRenderer`](#class-bundlerenderer) с сборкой сервера и (опциональными) [настройками](#renderer-options).

``` js
const { createBundleRenderer } = require('vue-server-renderer')
const renderer = createBundleRenderer(serverBundle, { ... })
```

Аргумент `serverBundle` может быть одним из следующих:

- Абсолютный путь к созданному файлу сборки (`.js` или `.json`). Должен начинаться с `/`, чтобы трактоваться как путь к файлу.

- Объект сборки, сгенерированный Webpack + `vue-server-renderer/server-plugin`.

- Строка с кодом JavaScript (не рекомендуется).

См. также [Представляем Bundle Renderer](./bundle-renderer.md) и [Конфигурация сборки](./build-config.md) для подробностей.

## `Класс: Renderer`

- #### `renderer.renderToString(vm[, context], callback)`

  Рендерит экземпляр Vue в строку. Объект контекста опционален. Коллбэк является обычным для Node.js коллбэком, где первый аргумент является ошибкой, а второй аргумент — отрендеренной строкой.

- #### `renderer.renderToStream(vm[, context])`

  Рендерит экземпляр Vue в поток (stream) Node.js. Объект контекста опционален. См. также [Стриминг](./streaming.md) для подробностей.

## `Класс: BundleRenderer`

- #### `bundleRenderer.renderToString([context, ]callback)`

  Рендерит сборку в строку. Объект контекста опционален. Коллбэк является обычным для Node.js коллбэком, где первый аргумент является ошибкой, а второй аргумент — отрендеренной строкой.

- #### `bundleRenderer.renderToStream([context])`

  Рендерит сборку в поток (stream) Node.js. Объект контекста опционален. См. также [Стриминг](./streaming.md) для подробностей.

## Настройки рендерера

- #### `template`

  Предоставляет шаблон для всей HTML-страницы. Шаблон должен содержать комментарий `<!--vue-ssr-outlet-->`, который определяет место подстановки отрендеренного контента приложения.

  Шаблон также поддерживает базовые интерполяции с использованием контекста рендера:

  - Используйте двойные фигурные скобки для интерполяции экранированного HTML;
  - Используйте тройные фигурные скобки для интерполяции сырого HTML.

  Шаблон автоматически внедряет соответствующий контент, когда определённые свойства найдены в контексте рендера:

  - `context.head`: (string) any head markup that should be injected into the head of the page.

  - `context.styles`: (string) any inline CSS that should be injected into the head of the page. Note this property will be automatically populated if using `vue-loader` + `vue-style-loader` for component CSS.

  - `context.state`: (Object) initial Vuex store state that should be inlined in the page as `window.__INITIAL_STATE__`. The inlined JSON is automatically sanitized with [serialize-javascript](https://github.com/yahoo/serialize-javascript) to prevent XSS.

  In addition, when `clientManifest` is also provided, the template automatically injects the following:

  - Client-side JavaScript and CSS assets needed by the render (with async chunks automatically inferred);
  - Optimal `<link rel="preload/prefetch">` resource hints for the rendered page.

  You can disable all automatic injections by also passing `inject: false` to the renderer.

  See also:

  - [Using a Page Template](./basic.md#using-a-page-template)
  - [Manual Asset Injection](./build-config.md#manual-asset-injection)

- #### `clientManifest`

  - 2.3.0+
  - only used in `createBundleRenderer`

  Provide a client build manifest object generated by `vue-server-renderer/server-plugin`. The client manifest provides the bundle renderer with the proper information for automatic asset injection into the HTML template. For more details, see [Generating clientManifest](./build-config.md#generating-clientmanifest).

- #### `inject`

  - 2.3.0+

  Controls whether to perform automatic injections when using `template`. Defaults to `true`.

  See also: [Manual Asset Injection](./build-config.md#manual-asset-injection).

- #### `shouldPreload`

  - 2.3.0+

  A function to control what files should have `<link rel="preload">` resource hints generated.

  By default, only JavaScript and CSS files will be preloaded, as they are absolutely needed for your application to boot.

  For other types of assets such as images or fonts, preloading too much may waste bandwidth and even hurt performance, so what to preload will be scenario-dependent. You can control precisely what to preload using the `shouldPreload` option:

  ``` js
  const renderer = createBundleRenderer(bundle, {
    template,
    clientManifest,
    shouldPreload: (file, type) => {
      // type is inferred based on the file extension.
      // https://fetch.spec.whatwg.org/#concept-request-destination
      if (type === 'script' || type === 'style') {
        return true
      }
      if (type === 'font') {
        // only preload woff2 fonts
        return /\.woff2$/.test(file)
      }
      if (type === 'image') {
        // only preload important images
        return file === 'hero.jpg'
      }
    }
  })
  ```

- #### `runInNewContext`

  - 2.3.0+
  - only used in `createBundleRenderer`

  By default, for each render the bundle renderer will create a fresh V8 context and re-execute the entire bundle. This has some benefits - for example, we don't need to worry about the "stateful singleton" problem we mentioned earlier. However, this mode comes at some considerable performance cost because re-executing the bundle is expensive especially when the app gets bigger.

  This option defaults to `true` for backwards compatibility, but it is recommended to use `runInNewContext: false` whenever you can.

  See also: [Source Code Structure](./structure.md)

- #### `basedir`

  - 2.2.0+
  - only used in `createBundleRenderer`

  Explicitly declare the base directory for the server bundle to resolve `node_modules` dependencies from. This is only needed if your generated bundle file is placed in a different location from where the externalized NPM dependencies are installed, or your `vue-server-renderer` is npm-linked into your current project.

- #### `cache`

  Provide a [component cache](./caching.md#component-level-caching) implementation. The cache object must implement the following interface (using Flow notations):

  ``` js
  type RenderCache = {
    get: (key: string, cb?: Function) => string | void;
    set: (key: string, val: string) => void;
    has?: (key: string, cb?: Function) => boolean | void;
  };
  ```

  A typical usage is passing in an [lru-cache](https://github.com/isaacs/node-lru-cache):

  ``` js
  const LRU = require('lru-cache')

  const renderer = createRenderer({
    cache: LRU({
      max: 10000
    })
  })
  ```

  Note that the cache object should at least implement `get` and `set`. In addition, `get` and `has` can be optionally async if they accept a second argument as callback. This allows the cache to make use of async APIs, e.g. a redis client:

  ``` js
  const renderer = createRenderer({
    cache: {
      get: (key, cb) => {
        redisClient.get(key, (err, res) => {
          // handle error if any
          cb(res)
        })
      },
      set: (key, val) => {
        redisClient.set(key, val)
      }
    }
  })
  ```

- #### `directives`

  Allows you to provide server-side implementations for your custom directives:

  ``` js
  const renderer = createRenderer({
    directives: {
      example (vnode, directiveMeta) {
        // transform vnode based on directive binding metadata
      }
    }
  })
  ```

  As an example, check out [`v-show`'s server-side implementation](https://github.com/vuejs/vue/blob/dev/src/platforms/web/server/directives/show.js).

## Webpack Plugins

The webpack plugins are provided as standalone files and should be required directly:

``` js
const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')
const VueSSRClientPlugin = require('vue-server-renderer/client-plugin')
```

The default files generated are:

- `vue-ssr-server-bundle.json` for the server plugin;
- `vue-ssr-client-manifest.json` for the client plugin.

The filenames can be customized when creating the plugin instances:

``` js
const plugin = new VueSSRServerPlugin({
  filename: 'my-server-bundle.json'
})
```

See [Build Configuration](./build-config.md) for more information.
